<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>设计模式第二篇之享元模式 | Hello 键盘</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="什么是享元模式？&amp;emsp;&amp;emsp;享元模式（英语：Flyweight Pattern）是一种软件设计模式。它使用共享物件，用来尽可能减少内存使用量以及分享资讯给尽可能多的相似物件；它适合用于只是因重复而导致使用无法令人接受的大量内存的大量物件。通常物件中的部分状态是可以分享。常见做法是把它们放在外部数据结构，当需要使用时再将它们传递给享元。来自百度百科">
<meta property="og:type" content="article">
<meta property="og:title" content="设计模式第二篇之享元模式">
<meta property="og:url" content="http://yoursite.com/2017/02/14/设计模式第二篇之享元模式/index.html">
<meta property="og:site_name" content="Hello 键盘">
<meta property="og:description" content="什么是享元模式？&amp;emsp;&amp;emsp;享元模式（英语：Flyweight Pattern）是一种软件设计模式。它使用共享物件，用来尽可能减少内存使用量以及分享资讯给尽可能多的相似物件；它适合用于只是因重复而导致使用无法令人接受的大量内存的大量物件。通常物件中的部分状态是可以分享。常见做法是把它们放在外部数据结构，当需要使用时再将它们传递给享元。来自百度百科">
<meta property="og:updated_time" content="2017-02-15T14:46:28.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="设计模式第二篇之享元模式">
<meta name="twitter:description" content="什么是享元模式？&amp;emsp;&amp;emsp;享元模式（英语：Flyweight Pattern）是一种软件设计模式。它使用共享物件，用来尽可能减少内存使用量以及分享资讯给尽可能多的相似物件；它适合用于只是因重复而导致使用无法令人接受的大量内存的大量物件。通常物件中的部分状态是可以分享。常见做法是把它们放在外部数据结构，当需要使用时再将它们传递给享元。来自百度百科">
  
    <link rel="alternate" href="/atom.xml" title="Hello 键盘" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hello 键盘</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">越努力 越幸运</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-设计模式第二篇之享元模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/14/设计模式第二篇之享元模式/" class="article-date">
  <time datetime="2017-02-14T12:21:35.000Z" itemprop="datePublished">2017-02-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      设计模式第二篇之享元模式
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="什么是享元模式？"><a href="#什么是享元模式？" class="headerlink" title="什么是享元模式？"></a>什么是享元模式？</h3><p>&emsp;&emsp;享元模式（英语：Flyweight Pattern）是一种软件设计模式。它使用共享物件，用来尽可能减少内存使用量以及分享资讯给尽可能多的相似物件；它适合用于只是因重复而导致使用无法令人接受的大量内存的大量物件。通常物件中的部分状态是可以分享。常见做法是把它们放在外部数据结构，当需要使用时再将它们传递给享元。<a href="http://baike.baidu.com/link?url=I0buNXCQLobfRfeXTivLl5Qwt3RfexNAF1-Yv1TAhMw4Why9Nv-rt3MkBWj8e5VhXrPz--CvrTdSLUqawtcOPGcaCBO9_5EHYxdimoaDuTsSwUGLxXUa-agP-w8AOJUt" target="_blank" rel="external">来自百度百科 </a></p>
<a id="more"></a>
<h3 id="享元模式的使用场景以及优点"><a href="#享元模式的使用场景以及优点" class="headerlink" title="享元模式的使用场景以及优点"></a>享元模式的使用场景以及优点</h3><p>&emsp;&emsp;如果一个应用程序使用了大量的对象，而这些对象造成了很大的开销时就可以考虑是否使用享元模式。比如某个对象生成了大量的实例，并且这些实例除了几个参数外基本是相同的，如果把那些共享参数转移到类外面，在方法调用的时候将他们传递进来，就可以通过共享大部分的实例数目已达到减少实例的目的。</p>
<p>&emsp;&emsp;享元对象中的部分状态是可以共享，可以共享的状态成为内部状态，内部状态不会随着环境的变化；不可共享的状态则称之为外部状态，它们会随着环境的改变而改变。在享元模式中会建立一个对象容器，在经典的享元模式中该容器为一个Map，它的键是享元对象的内部状态，它的值就是享元对象本身。客户端通过这个内部状态从享元工厂中获取对象，如果有缓存则使用缓存对象，否则就创建一个享元对象并存入容器中，这样一来就避免了创建过多对象的问题。</p>
<h3 id="主要几个角色分析"><a href="#主要几个角色分析" class="headerlink" title="主要几个角色分析"></a>主要几个角色分析</h3><ul>
<li>Flyweight：享元对象的抽象基类或接口；</li>
<li>ConcreteFlyweight:具体的享元对象；</li>
<li>FlyweightFactory：享元工厂，负责管理享元对象池和创建享元对象；</li>
</ul>
<h3 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h3><p>&emsp;&emsp;小米手机刚出来的时候都是要去抢购才买的到，大家是不是有这样的体验？那么N个人在下单的时候，对于每个订单的请求服务器都必须做出应答。在用户选择到所购的手机后，每次请求都返回一个订单结果。当N个人下单的时候如果每次都重新创建一个下单成功的结果，那么必然会造成大量重复对象的创建、销毁，使得GC任务繁重、内存占用率居高不下。而这类问题通过享元模式就能够得到很好的改善。</p>
<p>&emsp;&emsp;首先我们创建一个接口，该接口定义展示订单的信息的方法，具体代码如下：</p>
<pre><code>public interface Order {

    public void showOrderInfo(String postage);
}
</code></pre><p>&emsp;&emsp;它的一个具体的实现类是PhoneOrder，具体代码如下：</p>
<pre><code>public class PhoneOrder implements Order {

    private String blueTooth; //蓝牙
    private String pasting;   //贴膜
    private String postage;   //包邮
    private String phoneType; //手机型号
    private int price;

    public PhoneOrder(String phoneType) {
        this.phoneType = phoneType;
    }

    @Override
    public void showOrderInfo(String postage) {
        price = (int) (Math.random() * 2000);
        Log.i(&quot;test&quot;, &quot;购买的手机型号为：&quot; + phoneType + &quot;,是否包邮？&quot; + postage + &quot;,总价是：&quot; + price);
    }
}
</code></pre><p>&emsp;&emsp;如数据所示，订单的信息有蓝牙、贴膜、包邮、手机型号、价格，在用户下单的时候每次查询时如果没有使用某种缓存模式，那么返回订单的数据接口实现如下：</p>
<pre><code>public class OrderFactory {

    static Map&lt;String, PhoneOrder&gt; sOrderMap = new HashMap&lt;String, PhoneOrder&gt;();
    public static PhoneOrder getPhoneOrder(String phoneType){
        return new PhoneOrder(&quot;小米1&quot;);
    }
}
</code></pre><p>&emsp;&emsp;小米手机卖的很火爆，秒杀的时候有100万的用户在下单，那么订单对象就会被创建100万次，当数据返回之后这些对象变的没用了又会被虚拟机回收，此时就会造成大量的重复对象存在内存中，GC对这些对象的回收也会非常的消耗资源。如果用户的请求量很大可能导致系统变得极其缓慢，甚至可能导致OOM。</p>
<p>&emsp;&emsp;所以我们必须通过某种形式有效地减少重复对象的存在。它通过内部状态标识某个种类的对象，外部程序根据这个不会变化的内部状态从消息池中取出对象。使用同一类对象可以被重复用，避免大量重复的对象。通过享元模式，只需要简单的改造一下OrderFactory，具体代码如下：</p>
<pre><code>public class OrderFactory {

    static Map&lt;String, PhoneOrder&gt; sOrderMap = new HashMap&lt;String, PhoneOrder&gt;();

    public static PhoneOrder getPhoneOrder(String phoneType){
        String key = phoneType;
        if (sOrderMap.containsKey(key)) {
            Log.i(&quot;test&quot;, &quot;使用缓存 key =&quot; + key);
            return sOrderMap.get(key);
        }else {
            Log.i(&quot;test&quot;, &quot;创建对象 key =&quot; + key);
            PhoneOrder phoneOrder = new PhoneOrder(phoneType);
            sOrderMap.put(key, phoneOrder);
            return phoneOrder;
        }
    }

}
</code></pre><p>通过将手机型号作为内部状态，那么购买同个型号的手机订单就从100万个缩小到1个，避免了大量的内存占用以及频繁的GC操作。简单代码如下：</p>
<pre><code>public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);


        Button button = (Button) findViewById(R.id.btn);
        button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                PhoneOrder phoneOrder1 = OrderFactory.getPhoneOrder(&quot;小米1&quot;);
                phoneOrder1.showOrderInfo(&quot;包邮&quot;);
                PhoneOrder phoneOrder2 = OrderFactory.getPhoneOrder(&quot;小米1&quot;);
                phoneOrder2.showOrderInfo(&quot;不包邮&quot;);
                PhoneOrder phoneOrder3 = OrderFactory.getPhoneOrder(&quot;小米1&quot;);
                phoneOrder3.showOrderInfo(&quot;偏远地方加10块钱包邮&quot;);
                Log.i(&quot;test&quot;, &quot;onClick: ===============================================&quot;);
            }
        });
    }
}
</code></pre><p>我们分析下运行结果：</p>
<p> I/test: 创建对象 key =小米1</p>
<p> I/test: 购买的手机型号为：小米1,是否包邮？包邮,总价是：1356</p>
<p> I/test: 使用缓存 key =小米1</p>
<p> I/test: 购买的手机型号为：小米1,是否包邮？不包邮,总价是：773</p>
<p> I/test: 使用缓存 key =小米1</p>
<p> I/test: 购买的手机型号为：小米1,是否包邮？偏远地方加10块钱包邮,总价是：1953</p>
<p>从输出结果可以看出，只有第一次下单的时候创建了一次对象，后续的查询都使用的是订单池中的对象。这其实就相当于一个对象缓存，避免了对象的重复创建与回收。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/02/14/设计模式第二篇之享元模式/" data-id="cj601i6650005yayzuyq1kecg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/03/18/设计模式第三篇之状态模式/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          设计模式第三篇之状态模式
        
      </div>
    </a>
  
  
    <a href="/2017/02/03/单例模式/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">设计模式第一篇之单例模式</div>
    </a>
  
</nav>

  
</article>





  <section id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-设计模式第二篇之享元模式" data-title="设计模式第二篇之享元模式" data-url="http://yoursite.com/2017/02/14/设计模式第二篇之享元模式/"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'ambitionman868'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';
        ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  </section>
</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/08/06/临时性内存泄露分析/">Handler临时性内存泄露分析</a>
          </li>
        
          <li>
            <a href="/2017/03/19/设计模式第四篇之建造者模式/">设计模式第四篇之建造者模式</a>
          </li>
        
          <li>
            <a href="/2017/03/18/设计模式第三篇之状态模式/">设计模式第三篇之状态模式</a>
          </li>
        
          <li>
            <a href="/2017/02/14/设计模式第二篇之享元模式/">设计模式第二篇之享元模式</a>
          </li>
        
          <li>
            <a href="/2017/02/03/单例模式/">设计模式第一篇之单例模式</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 Ambition<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>